{"ast":null,"code":"/**\n *   REQUIRES\n */\nconst esprima = require('esprima');\n\nconst escodegen = require('escodegen');\n\nconst estraverse = require('estraverse');\n\nfunction getBigO(dataType, code) {\n  // Char sets\n  // const alnum = 'abcdefghijklmnopqrstuvwxyz0123456789';\n  // const alpha = 'abcdefghijklmnopqrstuvwxyz';\n  // const num = '0123456789';\n  // Declare data sets\n  let sets = [];\n  let n = [16, 32, 128, 256, 512, 1024, 2048, 4096]; // Populate data sets\n\n  switch (dataType) {\n    case \"integer\":\n      sets = n;\n      break;\n\n    case \"int-length-matters\":\n      sets = n;\n      n = [2, 2, 3, 3, 3, 4, 4, 4];\n      break;\n\n    case \"alpha-str\":\n    case \"alpha-num-str\":\n    case \"alpha-num-spec-str\":\n    case \"array-ints\":\n      for (let i = 0; i < 8; i++) {\n        let arr = [];\n\n        for (let j = 0; j < n[i]; j++) {\n          arr.push(Math.floor(Math.random() * 9));\n        }\n\n        sets[i] = arr;\n      }\n\n      break;\n\n    case \"array-rand-str\":\n    default:\n      break;\n  } //What if they do not use ; and the string that's sent to here includes \\n ... something like \"function foo() {let sum=0\\n let splitter = value.toString().split(\"\") .... etc.}\"\n  //what if they use \"\" in the code \n  //what about +=, -=\n  // BUILD AST \n\n\n  const ast = esprima.parse(`${code}`); // MODIFY AST\n\n  estraverse.traverse(ast, {\n    enter: function (node) {\n      if (node.type === \"BlockStatement\") {\n        injectBlockStatements(node);\n      }\n    }\n  }); // MUST change arrow functions to named functions because the parser add ; to the end of an arrow function (donno why?!) and i'm unable to immediately invoke\n\n  function injectBlockStatements(node) {\n    let addCounter = {\n      type: 'ExpressionStatement',\n      expression: {\n        type: 'AssignmentExpression',\n        left: {\n          name: 'counter',\n          type: 'Identifier'\n        },\n        operator: '+=',\n        right: {\n          value: 1,\n          type: 'Literal'\n        }\n      }\n    };\n    return node.body.unshift(addCounter);\n  } // CODE GEN / UNPARSE\n\n\n  const modified = escodegen.generate(ast).replaceAll(\"\\n\", \"\"); //  CALCULATE BIG O APPROX\n  // grab counters\n\n  const counters = [];\n\n  for (let i = 0; i < 8; i++) {\n    let counter = 0;\n    counters.push(eval(`(()=>{(${modified})(sets[${i}]); return counter;})()`));\n  }\n\n  let bigOEst;\n\n  if (counters[0] === counters[7]) {\n    bigOEst = \"O(1)\";\n  } else {\n    // make big o array\n    // ADD: log(n) and (2^n)\n    const ratioArr = [];\n\n    for (let i = 0; i < 8; i++) {\n      const tempArr = [];\n      tempArr.push(counters[i] / Math.log(n[i]));\n      tempArr.push(counters[i] / n[i] ** 0.5);\n      tempArr.push(counters[i] / n[i]);\n      tempArr.push(counters[i] / n[i] * Math.log(n[i]));\n      tempArr.push(counters[i] / n[i] ** 2);\n      ratioArr.push(tempArr);\n    }\n\n    const metaRatioArr = [];\n\n    for (let i = 0; i < 5; i++) {\n      metaRatioArr.push(Math.abs(1 - ratioArr[6][i] / ratioArr[7][i]));\n    }\n\n    let minDiff = [metaRatioArr[0], 0];\n\n    for (let i = 0; i < 5; i++) {\n      if (metaRatioArr[i] < minDiff[0]) {\n        minDiff = [metaRatioArr[i], i];\n      }\n    }\n\n    let est;\n\n    switch (minDiff[1]) {\n      case 0:\n        est = \"log(n)\";\n        break;\n\n      case 1:\n        est = \"n^(1/2)\";\n        break;\n\n      case 2:\n        est = \"n\";\n        break;\n\n      case 3:\n        est = \"n * log(n)\";\n        break;\n\n      case 4:\n        est = \"n^2\";\n        break;\n\n      default:\n        let error = \"There was an error, try again!\";\n        break;\n    }\n\n    bigOEst = `O(${est})`; // console.log(\"metaRatioArr\", metaRatioArr)\n  } // RETURN :   {error, bigO estimate, hottest lines}\n\n\n  return {\n    error: \"none\",\n    bigOEst: bigOEst,\n    hotLines: []\n  };\n}\n\nexport { esprima, escodegen, estraverse, getBigO };","map":{"version":3,"sources":["/Users/arunaevan/Development/code/Mod3/final_project_2/src/modules/calculator.js"],"names":["esprima","require","escodegen","estraverse","getBigO","dataType","code","sets","n","i","arr","j","push","Math","floor","random","ast","parse","traverse","enter","node","type","injectBlockStatements","addCounter","expression","left","name","operator","right","value","body","unshift","modified","generate","replaceAll","counters","counter","eval","bigOEst","ratioArr","tempArr","log","metaRatioArr","abs","minDiff","est","error","hotLines"],"mappings":"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","sourcesContent":["/**\n *   REQUIRES\n */ \n\nconst esprima = require('esprima');\nconst escodegen = require('escodegen');\nconst estraverse = require('estraverse');\n\nfunction getBigO(dataType, code){\n    // Char sets\n    // const alnum = 'abcdefghijklmnopqrstuvwxyz0123456789';\n    // const alpha = 'abcdefghijklmnopqrstuvwxyz';\n    // const num = '0123456789';\n\n    // Declare data sets\n        let sets = [];\n        let n = [16, 32, 128, 256, 512, 1024, 2048, 4096]\n\n    // Populate data sets\n        switch(dataType) {\n            case \"integer\":\n                sets = n;\n                break;\n            case \"int-length-matters\":\n                sets = n;\n                n = [2,2,3,3,3,4,4,4];\n                break;\n            case \"alpha-str\":\n            case \"alpha-num-str\":\n            case \"alpha-num-spec-str\":\n            case \"array-ints\":\n                for (let i=0; i<8; i++){\n                    let arr = [];\n                    for (let j=0; j<n[i]; j++) {\n                        arr.push(Math.floor(Math.random()*9))\n                    }\n                    sets[i] = arr;\n                }\n                break;\n            case \"array-rand-str\":\n            default:\n                break;\n        }\n\n    //What if they do not use ; and the string that's sent to here includes \\n ... something like \"function foo() {let sum=0\\n let splitter = value.toString().split(\"\") .... etc.}\"\n    //what if they use \"\" in the code \n    //what about +=, -=\n    \n    // BUILD AST \n\n        const ast = esprima.parse(`${code}`);\n\n\n    // MODIFY AST\n\n        estraverse.traverse(ast, {\n            enter: function(node) {\n                if (node.type === \"BlockStatement\") {\n                    injectBlockStatements(node);\n                }\n            }\n        });\n\n\n        // MUST change arrow functions to named functions because the parser add ; to the end of an arrow function (donno why?!) and i'm unable to immediately invoke\n\n        function injectBlockStatements(node) {\n            let addCounter = {\n                type: 'ExpressionStatement', \n                expression: {\n                    type:'AssignmentExpression',\n                    left: {name: 'counter', type: 'Identifier'},\n                    operator: '+=',\n                    right: {value: 1, type: 'Literal'}\n                }\n            }\n            return node.body.unshift(addCounter)\n        }\n\n\n    // CODE GEN / UNPARSE\n\n\n        const modified = escodegen.generate(ast).replaceAll(\"\\n\", \"\");\n\n\n    //  CALCULATE BIG O APPROX\n\n        // grab counters\n        const counters = [];\n        for (let i=0; i<8; i++) {\n            let counter = 0;\n            counters.push(eval(`(()=>{(${modified})(sets[${i}]); return counter;})()`));\n        }\n\n        let bigOEst;\n        if (counters[0] === counters[7]) {\n            bigOEst = \"O(1)\";\n        }\n        else{\n            // make big o array\n            // ADD: log(n) and (2^n)\n            const ratioArr = [];\n            for (let i=0; i<8; i++) {\n                const tempArr = [];\n                    tempArr.push(counters[i] / Math.log(n[i]));\n                    tempArr.push(counters[i] / n[i]**0.5);\n                    tempArr.push(counters[i] / n[i]);\n                    tempArr.push(counters[i] / n[i]*Math.log(n[i]));\n                    tempArr.push(counters[i] / n[i]**2);\n                ratioArr.push(tempArr);\n            }\n\n            const metaRatioArr = [];\n\n            for (let i=0; i<5; i++) {\n                metaRatioArr.push(Math.abs(1 - ratioArr[6][i]/ratioArr[7][i]));\n            }\n\n            let minDiff = [metaRatioArr[0], 0];\n            for (let i=0; i<5; i++) {\n                if (metaRatioArr[i] < minDiff[0]){\n                    minDiff = [metaRatioArr[i], i];\n                }\n            }\n            let est; \n            switch(minDiff[1]) {\n                case 0:\n                    est = \"log(n)\";\n                    break;\n                case 1:\n                    est = \"n^(1/2)\"\n                    break;\n                case 2:\n                    est = \"n\"\n                    break;\n                case 3:\n                    est = \"n * log(n)\"\n                    break;\n                case 4:\n                    est = \"n^2\"\n                    break;\n                default:\n                    let error = \"There was an error, try again!\";\n                    break;\n            }\n            bigOEst = `O(${est})`;\n\n            // console.log(\"metaRatioArr\", metaRatioArr)\n        }\n\n    // RETURN :   {error, bigO estimate, hottest lines}\n    return {error: \"none\", bigOEst: bigOEst, hotLines: []}\n}\n\n\nexport { esprima, escodegen, estraverse, getBigO }"]},"metadata":{},"sourceType":"module"}